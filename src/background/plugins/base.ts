/**
 * Plugin Base Architecture - Simple data structures
 */

import { SynapseEvent } from '../../shared/types';
import { AdaptedEvent, adaptSynapseEvent } from './EventAdapter';

// Linus: "Good programmers worry about data structures"
export interface PluginContext {
  stateManager: any;
  dataStorage: any;
  messageRouter: any;
  mlWorker: any;
}

export interface PluginSuggestion {
  id: string;
  confidence: number;
  priority: number;
  type: 'workflow' | 'clipboard' | 'prediction' | 'general';
  action: string;
  target?: string;
  data?: any;
  reason?: string;
}

export interface PluginCapability {
  readonly id: string;
  readonly name: string;
  readonly description: string;
  
  // Core methods - keep it simple
  initialize(context: PluginContext): Promise<void>;
  processEvent(event: AdaptedEvent): Promise<PluginSuggestion[]>;
  cleanup(): Promise<void>;
  
  // Optional lifecycle hooks
  onStateChange?(key: string, value: any): void;
  canHandle?(event: AdaptedEvent): boolean;
}

export abstract class BasePlugin implements PluginCapability {
  abstract readonly id: string;
  abstract readonly name: string;
  abstract readonly description: string;
  
  protected context!: PluginContext;
  protected isInitialized = false;
  
  async initialize(context: PluginContext): Promise<void> {
    this.context = context;
    this.isInitialized = true;
  }
  
  abstract processEvent(event: AdaptedEvent): Promise<PluginSuggestion[]>;
  
  async cleanup(): Promise<void> {
    this.isInitialized = false;
  }
  
  canHandle(event: AdaptedEvent): boolean {
    return true; // Default: handle all events, let processEvent decide
  }
  
  protected createSuggestion(
    type: PluginSuggestion['type'],
    action: string,
    confidence: number,
    priority: number = 1,
    data?: any
  ): PluginSuggestion {
    return {
      id: `${this.id}_${Date.now()}_${Math.random().toString(36).substring(2, 11)}`,
      type,
      action,
      confidence,
      priority,
      data,
      reason: `Generated by ${this.name}`
    };
  }
}

export class PluginRegistry {
  private plugins = new Map<string, PluginCapability>();
  private context!: PluginContext;
  
  setContext(context: PluginContext): void {
    this.context = context;
  }
  
  async register(plugin: PluginCapability): Promise<void> {
    if (this.plugins.has(plugin.id)) {
      console.warn(`[PluginRegistry] Plugin ${plugin.id} already registered`);
      return;
    }
    
    await plugin.initialize(this.context);
    this.plugins.set(plugin.id, plugin);
    console.log(`[PluginRegistry] Registered plugin: ${plugin.name}`);
  }
  
  async unregister(pluginId: string): Promise<void> {
    const plugin = this.plugins.get(pluginId);
    if (plugin) {
      await plugin.cleanup();
      this.plugins.delete(pluginId);
      console.log(`[PluginRegistry] Unregistered plugin: ${pluginId}`);
    }
  }
  
  getPlugin(pluginId: string): PluginCapability | undefined {
    return this.plugins.get(pluginId);
  }
  
  getAllPlugins(): PluginCapability[] {
    return Array.from(this.plugins.values());
  }
  
  async processEvent(event: SynapseEvent): Promise<PluginSuggestion[]> {
    const adaptedEvent = adaptSynapseEvent(event);
    const allSuggestions: PluginSuggestion[] = [];
    
    // Process event through all plugins that can handle it
    for (const plugin of this.plugins.values()) {
      if (plugin.canHandle && !plugin.canHandle(adaptedEvent)) {
        continue;
      }
      
      try {
        const suggestions = await plugin.processEvent(adaptedEvent);
        allSuggestions.push(...suggestions);
      } catch (error) {
        console.error(`[PluginRegistry] Error in plugin ${plugin.id}:`, error);
      }
    }
    
    return allSuggestions;
  }
  
  async cleanup(): Promise<void> {
    for (const plugin of this.plugins.values()) {
      try {
        await plugin.cleanup();
      } catch (error) {
        console.error(`[PluginRegistry] Error cleaning up plugin ${plugin.id}:`, error);
      }
    }
    this.plugins.clear();
  }
}